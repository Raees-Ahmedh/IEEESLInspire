import express from "express";
import { Request, Response } from "express";
import bcrypt from "bcryptjs";
import { prisma } from "../config/database";
import { addCourse, uploadCourseMaterial } from '../controllers/courseController';
import { authenticateToken, requireAdmin, requireAdminOrManager, requireAdminOrManagerOrEditor } from "../middleware/authMiddleware";

const router = express.Router();

// Type definitions for JSON fields
interface ProfileData {
  registrationDate?: string;
  registrationMethod?: string;
  university?: string;
  position?: string;
  department?: string;
  [key: string]: any;
}

interface AuditInfo {
  createdAt?: string;
  createdBy?: string;
  updatedAt?: string;
  updatedBy?: string;
  deletedAt?: string;
  deletedBy?: string;
  [key: string]: any;
}

// ======================== MANAGER MANAGEMENT ENDPOINTS (PROTECTED) ========================

// POST /api/admin/managers - Create new manager (Admin only)
router.post(
  "/managers",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const { email, password, firstName, lastName, phone } = req.body;

      // Validation
      if (!email || !password || !firstName) {
        return res.status(400).json({
          success: false,
          error: "Email, password, and first name are required",
        });
      }

      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          success: false,
          error: "Please provide a valid email address",
        });
      }

      // Check if user already exists
      const existingUser = await prisma.user.findUnique({
        where: { email },
      });

      if (existingUser) {
        return res.status(409).json({
          success: false,
          error: "User with this email already exists",
        });
      }

      console.log("👥 Creating new manager:", firstName, lastName);

      // Hash password
      const saltRounds = 12;
      const hashedPassword = await bcrypt.hash(password, saltRounds);

      // Audit info
      const auditInfo: AuditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: (req as any).user?.email || "admin",
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      // Create manager user
      const newManager = await prisma.user.create({
        data: {
          userType: "manager",
          email,
          passwordHash: hashedPassword,
          firstName,
          lastName,
          phone,
          role: "manager",
          profileData: {
            registrationDate: new Date().toISOString(),
            registrationMethod: "admin_created",
            position: "University Manager",
            department: "Academic Affairs",
          },
          isActive: true,
          auditInfo,
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          phone: true,
          role: true,
          isActive: true,
          profileData: true,
        },
      });

      console.log("✅ Manager created successfully:", newManager.id);

      res.status(201).json({
        success: true,
        data: {
          id: newManager.id.toString(),
          name: `${newManager.firstName} ${newManager.lastName || ""}`.trim(),
          email: newManager.email,
          isActive: newManager.isActive,
          role: newManager.role,
        },
        message: "Manager created successfully",
      });
    } catch (error: any) {
      console.error("❌ Error creating manager:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create manager",
        details: error.message,
      });
    }
  }
);

// GET /api/admin/managers - Get all managers (Admin only)
router.get(
  "/managers",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      console.log("👥 Fetching all managers...");

      const managers = await prisma.user.findMany({
        where: {
          role: "manager",
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          phone: true,
          isActive: true,
          profileData: true,
          lastLogin: true,
          auditInfo: true,
        },
        orderBy: {
          id: "desc",
        },
      });

      // Transform data for frontend
      const transformedManagers = managers.map(
        (manager: {
          id: number;
          email: string;
          firstName: string | null;
          lastName: string | null;
          phone: string | null;
          isActive: boolean;
          profileData: any;
          lastLogin: Date | null;
          auditInfo: any;
        }) => {
          const profileData = manager.profileData as ProfileData;
          const auditInfo = manager.auditInfo as AuditInfo;

          return {
            id: manager.id.toString(),
            name: `${manager.firstName} ${manager.lastName || ""}`.trim(),
            email: manager.email,
            university: "N/A",
            isActive: manager.isActive,
            createdAt: auditInfo?.createdAt || null,
            lastLogin: manager.lastLogin,
          };
        }
      );

      console.log(`✅ Found ${transformedManagers.length} managers`);

      res.json({
        success: true,
        data: transformedManagers,
        count: transformedManagers.length,
      });
    } catch (error: any) {
      console.error("❌ Error fetching managers:", error);
      res.status(500).json({
        success: false,
        error: "Failed to fetch managers",
        details: error.message,
      });
    }
  }
);

// PUT /api/admin/managers/:id/toggle-status - Toggle manager active status (Admin only)
router.put(
  "/managers/:id/toggle-status",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const managerId = parseInt(req.params.id);

      if (isNaN(managerId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid manager ID",
        });
      }

      // Find the manager
      const manager = await prisma.user.findFirst({
        where: {
          id: managerId,
          role: "manager",
        },
      });

      if (!manager) {
        return res.status(404).json({
          success: false,
          error: "Manager not found",
        });
      }

      // Type-safe access to auditInfo
      const currentAuditInfo = manager.auditInfo as AuditInfo;
      const updatedAuditInfo = {
        ...(currentAuditInfo || {}),
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      // Toggle active status
      const updatedManager = await prisma.user.update({
        where: { id: managerId },
        data: {
          isActive: !manager.isActive,
          auditInfo: updatedAuditInfo,
        },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          isActive: true,
          profileData: true,
        },
      });

      console.log(
        `✅ Manager ${updatedManager.isActive ? "activated" : "deactivated"}:`,
        updatedManager.email
      );

      res.json({
        success: true,
        data: {
          id: updatedManager.id.toString(),
          name: `${updatedManager.firstName} ${updatedManager.lastName || ""
            }`.trim(),
          email: updatedManager.email,
          isActive: updatedManager.isActive,
        },
        message: `Manager ${updatedManager.isActive ? "activated" : "deactivated"
          } successfully`,
      });
    } catch (error: any) {
      console.error("❌ Error toggling manager status:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update manager status",
        details: error.message,
      });
    }
  }
);


// POST /api/admin/editors - Create new editor with proper permissions
router.post(
  "/editors",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const { email, password, firstName, lastName, phone, accessRights = [], assignedUniversity } = req.body;

      if (!email || !password || !firstName) {
        return res.status(400).json({ success: false, error: "Email, password, and first name are required" });
      }

      const existingUser = await prisma.user.findUnique({ where: { email } });
      if (existingUser) {
        return res.status(409).json({ success: false, error: "User with this email already exists" });
      }

      const hashedPassword = await bcrypt.hash(password, 12);

      const auditInfo: AuditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: (req as any).user?.email || "admin",
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      // Create editor user first
      const newEditor = await prisma.user.create({
        data: {
          userType: "editor",
          email,
          passwordHash: hashedPassword,
          firstName,
          lastName,
          phone,
          role: "editor",
          profileData: {
            registrationDate: new Date().toISOString(),
            registrationMethod: "admin_created",
            assignedUniversity: assignedUniversity || null, // Store university assignment
          },
          isActive: true,
          auditInfo,
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          phone: true,
          role: true,
          isActive: true,
          profileData: true,
        },
      });

      // Create permission mapping function
      const mapAccessRightToPermission = (accessRight: string) => {
        const permissionMap: { [key: string]: { permissionType: string; resourceType: string; permissionDetails?: any } } = {
          'news_management': {
            permissionType: 'manage',
            resourceType: 'news_articles',
            permissionDetails: { actions: ['create', 'read', 'update', 'delete', 'publish'] }
          },
          'events_management': {
            permissionType: 'manage',
            resourceType: 'events',
            permissionDetails: { actions: ['create', 'read', 'update', 'delete'] }
          }
        };

        return permissionMap[accessRight] || {
          permissionType: 'custom',
          resourceType: 'general',
          permissionDetails: { customRight: accessRight }
        };
      };

      // Create user permissions in the user_permissions table
      const permissionPromises = accessRights.map(async (accessRight: string) => {
        const permissionData = mapAccessRightToPermission(accessRight);

        return prisma.userPermission.create({
          data: {
            userId: newEditor.id,
            permissionType: permissionData.permissionType,
            resourceType: permissionData.resourceType,
            permissionDetails: permissionData.permissionDetails || {},
            grantedBy: (req as any).user?.id || 1, // ID of the manager/admin granting permission
            grantedAt: new Date(),
            isActive: true,
            auditInfo: {
              createdAt: new Date().toISOString(),
              createdBy: (req as any).user?.email || "admin",
              updatedAt: new Date().toISOString(),
              updatedBy: (req as any).user?.email || "admin",
            },
          },
        });
      });

      // Execute all permission creations
      await Promise.all(permissionPromises);

      console.log(`✅ Created editor with ${accessRights.length} permissions:`, {
        editorId: newEditor.id,
        email: newEditor.email,
        permissions: accessRights
      });

      res.status(201).json({
        success: true,
        data: {
          id: newEditor.id.toString(),
          name: `${newEditor.firstName} ${newEditor.lastName || ""}`.trim(),
          email: newEditor.email,
          isActive: newEditor.isActive,
          role: newEditor.role,
          accessRights: accessRights, // Return the original access rights for frontend
          assignedUniversity: assignedUniversity || null,
        },
        message: "Editor created successfully with permissions",
      });
    } catch (error: any) {
      console.error("❌ Error creating editor:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create editor",
        details: error.message
      });
    }
  }
);

// GET /api/admin/editors - Get all editors
// GET /api/admin/editors - Get all editors with permissions from user_permissions table
router.get(
  "/editors",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const editors = await prisma.user.findMany({
        where: { role: "editor" },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          phone: true,
          isActive: true,
          profileData: true,
          lastLogin: true,
          auditInfo: true,
          permissions: {
            where: { isActive: true },
            select: {
              id: true,
              permissionType: true,
              resourceType: true,
              permissionDetails: true,
              grantedAt: true,
              expiresAt: true,
            },
          },
        },
        orderBy: { id: "desc" },
      });

      // Function to map permissions back to access rights for frontend compatibility
      const mapPermissionsToAccessRights = (permissions: any[]): string[] => {
        const reversePermissionMap: { [key: string]: string } = {
          'manage_news_articles': 'news_management',
          'manage_events': 'events_management',

        };

        return permissions.map(permission => {
          const key = `${permission.permissionType}_${permission.resourceType}`;
          return reversePermissionMap[key] || permission.permissionType;
        }).filter(Boolean);
      };

      const transformedEditors = editors.map((editor) => {
        const accessRights = mapPermissionsToAccessRights(editor.permissions);
        const profileData = editor.profileData as any;

        return {
          id: editor.id.toString(),
          name: `${editor.firstName} ${editor.lastName || ""}`.trim(),
          email: editor.email,
          isActive: editor.isActive,
          accessRights: accessRights,
          assignedUniversity: profileData?.assignedUniversity || null,
          lastLogin: editor.lastLogin,
          permissionCount: editor.permissions.length,
          permissions: editor.permissions, // Include full permission details if needed
        };
      });

      console.log(`✅ Fetched ${transformedEditors.length} editors with permissions`);

      res.json({
        success: true,
        data: transformedEditors,
        count: transformedEditors.length
      });
    } catch (error: any) {
      console.error("❌ Error fetching editors:", error);
      res.status(500).json({
        success: false,
        error: "Failed to fetch editors",
        details: error.message
      });
    }
  }
);

// PUT /api/admin/editors/:id/toggle-status
// PUT /api/admin/editors/:id/permissions - Update editor permissions
router.put(
  "/editors/:id/permissions",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const editorId = parseInt(req.params.id);
      const { accessRights = [] } = req.body;

      if (isNaN(editorId)) {
        return res.status(400).json({ success: false, error: "Invalid editor ID" });
      }

      const editor = await prisma.user.findFirst({
        where: { id: editorId, role: "editor" }
      });

      if (!editor) {
        return res.status(404).json({ success: false, error: "Editor not found" });
      }

      // Deactivate all existing permissions for this editor
      await prisma.userPermission.updateMany({
        where: {
          userId: editorId,
          isActive: true
        },
        data: {
          isActive: false,
          auditInfo: {
            updatedAt: new Date().toISOString(),
            updatedBy: (req as any).user?.email || "admin",
            deactivatedAt: new Date().toISOString(),
            deactivatedBy: (req as any).user?.email || "admin",
          }
        },
      });

      // Create permission mapping function (same as in POST route)
      const mapAccessRightToPermission = (accessRight: string) => {
        const permissionMap: { [key: string]: { permissionType: string; resourceType: string; permissionDetails?: any } } = {
          'news_management': {
            permissionType: 'manage',
            resourceType: 'news_articles',
            permissionDetails: { actions: ['create', 'read', 'update', 'delete', 'publish'] }
          },
          'events_management': {
            permissionType: 'manage',
            resourceType: 'events',
            permissionDetails: { actions: ['create', 'read', 'update', 'delete'] }
          }
        };

        return permissionMap[accessRight] || {
          permissionType: 'custom',
          resourceType: 'general',
          permissionDetails: { customRight: accessRight }
        };
      };

      // Create new permissions
      const permissionPromises = accessRights.map(async (accessRight: string) => {
        const permissionData = mapAccessRightToPermission(accessRight);

        return prisma.userPermission.create({
          data: {
            userId: editorId,
            permissionType: permissionData.permissionType,
            resourceType: permissionData.resourceType,
            permissionDetails: permissionData.permissionDetails || {},
            grantedBy: (req as any).user?.id || 1,
            grantedAt: new Date(),
            isActive: true,
            auditInfo: {
              createdAt: new Date().toISOString(),
              createdBy: (req as any).user?.email || "admin",
              updatedAt: new Date().toISOString(),
              updatedBy: (req as any).user?.email || "admin",
            },
          },
        });
      });

      await Promise.all(permissionPromises);

      console.log(`✅ Updated permissions for editor ${editorId}:`, accessRights);

      res.json({
        success: true,
        data: {
          editorId: editorId.toString(),
          accessRights: accessRights,
          permissionCount: accessRights.length,
        },
        message: "Editor permissions updated successfully",
      });
    } catch (error: any) {
      console.error("❌ Error updating editor permissions:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update editor permissions",
        details: error.message
      });
    }
  }
);
// ======================== UNIVERSITY MANAGEMENT ENDPOINTS ========================

// GET /api/admin/universities - Get all universities with recognition criteria
router.get("/universities", async (req: Request, res: Response) => {
  try {
    const { limit = "50", search, type, recognitionCriteria } = req.query;

    const whereClause: any = { isActive: true };

    if (search) {
      whereClause.name = {
        contains: search as string,
        mode: "insensitive",
      };
    }

    if (type && type !== "all") {
      whereClause.type = type;
    }

    // Filter by recognition criteria
    if (recognitionCriteria && recognitionCriteria !== "all") {
      whereClause.recognitionCriteria = {
        has: recognitionCriteria as string,
      };
    }

    // Use any type to bypass TypeScript issues
    const universities: any[] = await prisma.university.findMany({
      where: whereClause,
      include: {
        _count: {
          select: {
            faculties: true,
            courses: true,
          },
        },
      },
      take: parseInt(limit as string),
      orderBy: [{ type: "asc" }, { name: "asc" }],
    });

    const transformedUniversities = universities.map((uni: any) => ({
      id: uni.id,
      name: uni.name,
      type: uni.type,
      uniCode: uni.uniCode,
      address: uni.address,
      website: uni.website,
      recognitionCriteria: uni.recognitionCriteria || [],
      imageUrl: uni.imageUrl,
      logoUrl: uni.logoUrl,
      galleryImages: uni.galleryImages,
      additionalDetails: uni.additionalDetails,
      contactInfo: uni.contactInfo,
      facultiesCount: uni._count?.faculties || 0,
      coursesCount: uni._count?.courses || 0,
      isActive: uni.isActive,
      auditInfo: uni.auditInfo,
    }));

    res.json({
      success: true,
      data: transformedUniversities,
      count: transformedUniversities.length,
    });
  } catch (error: any) {
    console.error("Error fetching universities:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch universities",
      details: error.message,
    });
  }
});

// POST /api/admin/universities - Create new university
router.post(
  "/universities",
  //authenticateToken,
  //requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const {
        name,
        type,
        uniCode,
        address,
        contactInfo,
        website,
        recognitionCriteria = [],
        imageUrl,
        logoUrl,
        galleryImages,
        additionalDetails,
      } = req.body;

      // Validation
      if (!name || !type || !address || !uniCode) {
        return res.status(400).json({
          success: false,
          error: "Missing required fields",
          details: "Name, type, address, and university code are required",
        });
      }

      // Check if university code already exists
      const existingUniversity = await prisma.university.findUnique({
        where: { uniCode: uniCode.toUpperCase() },
      });

      if (existingUniversity) {
        return res.status(400).json({
          success: false,
          error: "University code already exists",
          details: `A university with code "${uniCode}" already exists`,
        });
      }

      // Prepare audit info
      const auditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: "admin@system.com", // You can replace this with actual user from token
        updatedAt: new Date().toISOString(),
        updatedBy: "admin@system.com",
      };

      // Create university
      const university = await prisma.university.create({
        data: {
          name: name.trim(),
          type,
          uniCode: uniCode.toUpperCase().trim(),
          address: address.trim(),
          contactInfo: contactInfo || null,
          website: website?.trim() || null,
          recognitionCriteria: recognitionCriteria || [],
          imageUrl: imageUrl?.trim() || null,
          logoUrl: logoUrl?.trim() || null,
          galleryImages: galleryImages || null,
          additionalDetails: additionalDetails || null,
          isActive: true,
          auditInfo: auditInfo,
        },
      });

      console.log(`✅ University created: ${university.name} (${university.uniCode})`);

      res.status(201).json({
        success: true,
        data: university,
        message: "University created successfully",
      });
    } catch (error: any) {
      console.error("❌ Error creating university:", error);

      // Handle unique constraint violations
      if (error.code === 'P2002') {
        return res.status(400).json({
          success: false,
          error: "University code already exists",
          details: "Please choose a different university code",
        });
      }

      res.status(500).json({
        success: false,
        error: "Failed to create university",
        details: error.message,
      });
    }
  }
);

// PUT /api/admin/universities/:id - Update university with recognition criteria
router.put(
  "/universities/:id",
  //authenticateToken,
  //requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const universityId = parseInt(req.params.id);
      const updateData = { ...req.body };

      if (isNaN(universityId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid university ID",
        });
      }

      // Get current university
      const currentUniversity: any = await prisma.university.findUnique({
        where: { id: universityId },
      });

      if (!currentUniversity) {
        return res.status(404).json({
          success: false,
          error: "University not found",
        });
      }

      // Update audit info
      const currentAuditInfo = currentUniversity.auditInfo as any;
      updateData.auditInfo = {
        ...currentAuditInfo,
        updatedAt: new Date().toISOString(),
        updatedBy: "admin@system.com",
      };

      // Use raw query for update to handle recognition criteria
      const updatedUniversity = await prisma.$queryRaw`
      UPDATE universities SET
        name = COALESCE(${updateData.name}, name),
        type = COALESCE(${updateData.type}, type),
        uni_code = COALESCE(${updateData.uniCode}, uni_code),
        address = COALESCE(${updateData.address}, address),
        contact_info = COALESCE(${updateData.contactInfo ? JSON.stringify(updateData.contactInfo) : null
        }::jsonb, contact_info),
        website = COALESCE(${updateData.website}, website),
        recognition_criteria = COALESCE(${updateData.recognitionCriteria || []
        }::text[], recognition_criteria),
        image_url = COALESCE(${updateData.imageUrl}, image_url),
        logo_url = COALESCE(${updateData.logoUrl}, logo_url),
        gallery_images = COALESCE(${updateData.galleryImages
          ? JSON.stringify(updateData.galleryImages)
          : null
        }::jsonb, gallery_images),
        additional_details = COALESCE(${updateData.additionalDetails
          ? JSON.stringify(updateData.additionalDetails)
          : null
        }::jsonb, additional_details),
        audit_info = ${JSON.stringify(updateData.auditInfo)}::jsonb
      WHERE university_id = ${universityId}
      RETURNING *
    `;

      res.json({
        success: true,
        data: updatedUniversity,
        message: "University updated successfully",
      });
    } catch (error: any) {
      console.error("Error updating university:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update university",
        details: error.message,
      });
    }
  }
);

// PUT /api/admin/universities/:id/status - Update university status
router.put(
  "/universities/:id/status",
  //authenticateToken,
  // requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const universityId = parseInt(req.params.id);
      const { isActive } = req.body;

      if (isNaN(universityId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid university ID",
        });
      }

      if (typeof isActive !== "boolean") {
        return res.status(400).json({
          success: false,
          error: "isActive must be a boolean value",
        });
      }

      // Check if university exists
      const existingUniversity = await prisma.university.findUnique({
        where: { id: universityId },
      });

      if (!existingUniversity) {
        return res.status(404).json({
          success: false,
          error: "University not found",
        });
      }

      // Update audit info
      const currentAuditInfo = existingUniversity.auditInfo as any;
      const updatedAuditInfo = {
        ...currentAuditInfo,
        updatedAt: new Date().toISOString(),
        updatedBy: "admin@system.com", // Replace with actual user from token
      };

      // Update university status
      const updatedUniversity = await prisma.university.update({
        where: { id: universityId },
        data: {
          isActive,
          auditInfo: updatedAuditInfo,
        },
      });

      console.log(
        `✅ University ${isActive ? "activated" : "deactivated"}: ${updatedUniversity.name}`
      );

      res.json({
        success: true,
        data: updatedUniversity,
        message: `University ${isActive ? "activated" : "deactivated"} successfully`,
      });
    } catch (error: any) {
      console.error("❌ Error updating university status:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update university status",
        details: error.message,
      });
    }
  }
);

// POST /api/admin/universities/bulk-update-images - Bulk update images
router.post(
  "/universities/bulk-update-images",
  //authenticateToken,
  //requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const updates = req.body.updates || [];

      const results = [];
      for (const update of updates) {
        try {
          const updatedUniversity = await prisma.$queryRaw`
          UPDATE universities SET
            image_url = ${update.imageUrl || null},
            logo_url = ${update.logoUrl || null},
            gallery_images = ${update.galleryImages ? JSON.stringify(update.galleryImages) : null
            }::jsonb
          WHERE name = ${update.name}
        `;
          results.push({ name: update.name, success: true });
        } catch (error: any) {
          results.push({
            name: update.name,
            success: false,
            error: error.message,
          });
        }
      }

      console.log(
        `✅ Bulk updated images for ${results.filter((r) => r.success).length
        } universities`
      );

      res.json({
        success: true,
        data: results,
        message: "Bulk image update completed",
      });
    } catch (error: any) {
      console.error("❌ Error in bulk update:", error);
      res.status(500).json({
        success: false,
        error: "Failed to bulk update images",
        details: error.message,
      });
    }
  }
);

// ======================== COURSE REQUIREMENTS MANAGEMENT (DISABLED - Using courseManagementRoutes.ts) ========================
// POST /api/admin/courses - Create course (Editor, Manager, Admin)
// router.post(
//   "/courses",
//   authenticateToken,                    // Verify JWT token
//   requireAdminOrManagerOrEditor,        // Allow Editor, Manager, Admin roles
//   addCourse                            // Use the controller function
// );

// POST /api/admin/courses/:courseId/materials - Upload course materials (DISABLED)
// router.post(
//   "/courses/:courseId/materials",
//   authenticateToken,
//   requireAdminOrManagerOrEditor,
//   uploadCourseMaterial
// );

// GET /api/admin/course-requirements - Get all course requirements with OL grades
router.get("/course-requirements", async (req: Request, res: Response) => {
  try {
    const { limit = "50", courseId } = req.query;

    const whereClause: any = { isActive: true };

    if (courseId) {
      whereClause.courseId = parseInt(courseId as string);
    }

    // Use any type to handle ruleOLGrades
    const requirements: any[] = await prisma.courseRequirement.findMany({
      where: whereClause,
      include: {
        courses: {
          select: {
            id: true,
            name: true,
            courseCode: true,
            university: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
      take: parseInt(limit as string),
      orderBy: { id: "desc" },
    });

    // Transform to include ruleOLGrades
    const transformedRequirements = requirements.map((req: any) => ({
      id: req.id,
      courseId: req.courseId,
      minRequirement: req.minRequirement,
      stream: req.stream,
      ruleSubjectBasket: req.ruleSubjectBasket,
      ruleSubjectGrades: req.ruleSubjectGrades,
      ruleOLGrades: req.ruleOLGrades,
      isActive: req.isActive,
      courses: req.courses,
    }));

    res.json({
      success: true,
      data: transformedRequirements,
      count: transformedRequirements.length,
    });
  } catch (error: any) {
    console.error("Error fetching course requirements:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch course requirements",
      details: error.message,
    });
  }
});

// POST /api/admin/course-requirements - Create course requirement with OL grades
router.post(
  "/course-requirements",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const {
        courseId,
        minRequirement,
        stream,
        ruleSubjectBasket,
        ruleSubjectGrades,
        ruleOLGrades,
      } = req.body;

      // Validation
      if (!minRequirement || !stream || !Array.isArray(stream)) {
        return res.status(400).json({
          success: false,
          error: "minRequirement and stream array are required",
        });
      }

      const auditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: "admin@system.com",
        updatedAt: new Date().toISOString(),
        updatedBy: "admin@system.com",
      };

      // Use raw query to create requirement with ruleOLGrades
      const requirement = await prisma.$queryRaw`
      INSERT INTO course_requirements (
        course_id, min_requirement, stream, rule_subjectBasket, 
        rule_subjectGrades, rule_OLGrades, audit_info, is_active
      ) VALUES (
        ${courseId || null}, ${minRequirement}, ${stream}::int[],
        ${ruleSubjectBasket ? JSON.stringify(ruleSubjectBasket) : null}::jsonb,
        ${ruleSubjectGrades ? JSON.stringify(ruleSubjectGrades) : null}::jsonb,
        ${ruleOLGrades ? JSON.stringify(ruleOLGrades) : null}::jsonb,
        ${JSON.stringify(auditInfo)}::jsonb, true
      ) RETURNING *
    `;

      res.status(201).json({
        success: true,
        data: requirement,
        message: "Course requirement created successfully",
      });
    } catch (error: any) {
      console.error("Error creating course requirement:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create course requirement",
        details: error.message,
      });
    }
  }
);

// PUT /api/admin/course-requirements/:id - Update course requirement with OL grades
router.put(
  "/course-requirements/:id",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const requirementId = parseInt(req.params.id);
      const updateData = { ...req.body };

      if (isNaN(requirementId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid requirement ID",
        });
      }

      // Get current requirement
      const currentRequirement: any = await prisma.courseRequirement.findUnique(
        {
          where: { id: requirementId },
        }
      );

      if (!currentRequirement) {
        return res.status(404).json({
          success: false,
          error: "Course requirement not found",
        });
      }

      // Update audit info
      const currentAuditInfo = currentRequirement.auditInfo as any;
      updateData.auditInfo = {
        ...currentAuditInfo,
        updatedAt: new Date().toISOString(),
        updatedBy: "admin@system.com",
      };

      // Use raw query for update
      const updatedRequirement = await prisma.$queryRaw`
      UPDATE course_requirements SET
        course_id = COALESCE(${updateData.courseId}, course_id),
        min_requirement = COALESCE(${updateData.minRequirement
        }, min_requirement),
        stream = COALESCE(${updateData.stream || []}::int[], stream),
        rule_subjectBasket = COALESCE(${updateData.ruleSubjectBasket
          ? JSON.stringify(updateData.ruleSubjectBasket)
          : null
        }::jsonb, rule_subjectBasket),
        rule_subjectGrades = COALESCE(${updateData.ruleSubjectGrades
          ? JSON.stringify(updateData.ruleSubjectGrades)
          : null
        }::jsonb, rule_subjectGrades),
        rule_OLGrades = COALESCE(${updateData.ruleOLGrades
          ? JSON.stringify(updateData.ruleOLGrades)
          : null
        }::jsonb, rule_OLGrades),
        audit_info = ${JSON.stringify(updateData.auditInfo)}::jsonb
      WHERE requirement_id = ${requirementId}
      RETURNING *
    `;

      res.json({
        success: true,
        data: updatedRequirement,
        message: "Course requirement updated successfully",
      });
    } catch (error: any) {
      console.error("Error updating course requirement:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update course requirement",
        details: error.message,
      });
    }
  }
);

// ======================== COURSE SEARCH AND MANAGEMENT ENDPOINTS ========================

// GET /api/admin/courses/search - Search courses by name (DISABLED - Using courseManagementRoutes.ts)
// router.get("/courses/search", async (req: Request, res: Response) => {
  try {
    const { name, limit = 10 } = req.query;

    if (!name || (name as string).length < 2) {
      return res.json({
        success: true,
        data: [],
      });
    }

    // Search courses with comprehensive details for auto-fill functionality
    const courses = await prisma.course.findMany({
      where: {
        name: {
          contains: name as string,
          mode: "insensitive",
        },
        isActive: true,
      },
      include: {
        university: {
          select: {
            id: true,
            name: true,
          },
        },
        faculty: {
          select: {
            id: true,
            name: true,
          },
        },
        department: {
          select: {
            id: true,
            name: true,
          },
        },
        framework: {
          select: {
            id: true,
            type: true,
            level: true,
            qualificationCategory: true,
          },
        },
        requirements: true,
      },
      take: parseInt(limit as string),
      orderBy: { name: "asc" },
    });

    // Transform the response to include fields needed for auto-fill
    const transformedCourses = courses.map((course: any) => ({
      id: course.id,
      name: course.name,
      courseCode: course.courseCode,
      courseUrl: course.courseUrl,
      description: course.description,
      specialisation: course.specialisation,
      universityId: course.universityId,
      facultyId: course.facultyId,
      departmentId: course.departmentId,
      studyMode: course.studyMode,
      courseType: course.courseType,
      frameworkId: course.frameworkId,
      feeType: course.feeType,
      feeAmount: course.feeAmount,
      durationMonths: course.durationMonths,
      medium: course.medium,
      zscore: course.zscore,
      subfieldId: course.subfieldId,
      careerId: course.careerId,
      materialIds: course.materialIds,
      additionalDetails: course.additionalDetails,

      // Related data for auto-fill
      university: course.university,
      faculty: course.faculty,
      department: course.department,
      framework: course.framework,
      requirements: course.requirements
        ? {
          id: course.requirements.id,
          minRequirement: course.requirements.minRequirement,
          stream: course.requirements.stream,
          ruleSubjectBasket: course.requirements.ruleSubjectBasket,
          ruleSubjectGrades: course.requirements.ruleSubjectGrades,
          ruleOLGrades: (course.requirements as any).ruleOLGrades,
        }
        : null,
    }));

    res.json({
      success: true,
      data: transformedCourses,
    });
  } catch (error: any) {
    console.error("Error searching courses:", error);
    res.status(500).json({
      success: false,
      error: "Failed to search courses",
      details: error.message,
    });
  }
});

// GET /api/admin/courses/:id - Get full course details for editing (RESTORED complete functionality)
router.get("/courses/:id", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const courseId = parseInt(id);

    if (isNaN(courseId)) {
      return res.status(400).json({
        success: false,
        error: "Invalid course ID",
      });
    }

    // Use any type for course to handle new fields
    const course: any = await prisma.course.findUnique({
      where: {
        id: courseId,
        isActive: true,
      },
      include: {
        university: true,
        faculty: true,
        department: true,
        framework: true,
        requirements: true,
      },
    });

    if (!course) {
      return res.status(404).json({
        success: false,
        error: "Course not found",
      });
    }

    // Get career pathways by IDs (RESTORED)
    let careerPathways: Array<{
      id: number;
      jobTitle: string;
      industry: string | null;
      description: string | null;
      salaryRange: string | null;
    }> = [];

    if (course.careerId && course.careerId.length > 0) {
      careerPathways = await prisma.careerPathway.findMany({
        where: {
          id: { in: course.careerId },
          isActive: true,
        },
        select: {
          id: true,
          jobTitle: true,
          industry: true,
          description: true,
          salaryRange: true,
        },
      });
    }

    // Get course materials by IDs (RESTORED)
    let courseMaterials: Array<{
      id: number;
      materialType: string;
      fileName: string;
      filePath: string;
      fileType: string | null;
      fileSize: number | null;
    }> = [];

    if (course.materialIds && course.materialIds.length > 0) {
      courseMaterials = await prisma.courseMaterial.findMany({
        where: {
          id: { in: course.materialIds },
        },
        select: {
          id: true,
          materialType: true,
          fileName: true,
          filePath: true,
          fileType: true,
          fileSize: true,
        },
      });
    }

    // Get sub fields by IDs (RESTORED)
    let subFields: Array<{
      id: number;
      name: string;
      description: string | null;
      majorField: {
        id: number;
        name: string;
      };
    }> = [];

    let majorFields: Array<{
      id: number;
      name: string;
    }> = [];

    if (course.subfieldId && course.subfieldId.length > 0) {
      subFields = await prisma.subField.findMany({
        where: {
          id: { in: course.subfieldId },
          isActive: true,
        },
        include: {
          majorField: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      // Extract unique major fields from sub fields
      const majorFieldMap = new Map<number, { id: number; name: string }>();
      subFields.forEach((sf) => {
        if (sf.majorField) {
          majorFieldMap.set(sf.majorField.id, sf.majorField);
        }
      });
      majorFields = Array.from(majorFieldMap.values());
    }

    // Transform the data to include new fields (COMPLETE RESTORATION)
    const courseData = {
      id: course.id,
      name: course.name,
      courseCode: course.courseCode,
      courseUrl: course.courseUrl,
      description: course.description,
      specialisation: course.specialisation,
      universityId: course.universityId,
      facultyId: course.facultyId,
      departmentId: course.departmentId,
      studyMode: course.studyMode,
      courseType: course.courseType,
      frameworkId: course.frameworkId,
      framework: course.framework,
      feeType: course.feeType,
      feeAmount: course.feeAmount,
      durationMonths: course.durationMonths,
      medium: course.medium,
      zscore: course.zscore,

      // Transform related data based on your schema (RESTORED)
      majorFieldIds: majorFields.map((mf) => mf.id),
      subFieldIds: course.subfieldId,
      careerId: course.careerId,
      materialIds: course.materialIds,

      // Requirements data with new OL grades field
      requirements: course.requirements
        ? {
          id: course.requirements.id,
          minRequirement: course.requirements.minRequirement,
          stream: course.requirements.stream,
          ruleSubjectBasket: course.requirements.ruleSubjectBasket,
          ruleSubjectGrades: course.requirements.ruleSubjectGrades,
          ruleOLGrades: course.requirements.ruleOLGrades, // NEW: Include OL grades rule
        }
        : null,

      // Additional details (JSON field from your schema)
      additionalDetails: course.additionalDetails || {},

      // Related models with new fields (RESTORED)
      university: {
        ...course.university,
        recognitionCriteria: course.university?.recognitionCriteria || [],
      },
      faculty: course.faculty,
      department: course.department,
      careerPathways: careerPathways, // RESTORED
      courseMaterials: courseMaterials, // RESTORED
      subFields: subFields, // RESTORED
      majorFields: majorFields, // RESTORED
    };

    res.json({
      success: true,
      data: courseData,
    });
  } catch (error: any) {
    console.error("Error fetching course details:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch course details",
      details: error.message,
    });
  }
});

// ======================== TASK MANAGEMENT ENDPOINTS ========================

// GET /api/admin/tasks - Get all tasks (for managers - only tasks they created)
router.get(
  "/tasks",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;

      // Build query based on user role
      const whereClause = userRole === 'admin'
        ? {} // Admin can see all tasks
        : { assignedBy: userId }; // Manager can only see tasks they created

      const tasks = await prisma.task.findMany({
        where: whereClause,
        include: {
          assignee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          assigner: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
        orderBy: {
          id: 'desc', // Order by newest first
        },
      });

      res.json({
        success: true,
        data: tasks,
        count: tasks.length,
      });
    } catch (error) {
      console.error('Get tasks error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch tasks',
      });
    }
  }
);

// POST /api/admin/tasks - Create new task
router.post(
  "/tasks",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.id;
      const { title, description, assignedTo, priority, dueDate } = req.body;

      // Validation
      if (!title || !assignedTo || !priority) {
        return res.status(400).json({
          success: false,
          error: "Title, assigned user, and priority are required",
        });
      }

      // Verify assigned user exists and is an editor
      const assignedUser = await prisma.user.findUnique({
        where: { id: parseInt(assignedTo) },
        select: { id: true, role: true, isActive: true }
      });

      if (!assignedUser) {
        return res.status(400).json({
          success: false,
          error: "Assigned user not found",
        });
      }

      if (assignedUser.role !== 'editor') {
        return res.status(400).json({
          success: false,
          error: "Tasks can only be assigned to editors",
        });
      }

      if (!assignedUser.isActive) {
        return res.status(400).json({
          success: false,
          error: "Cannot assign tasks to inactive users",
        });
      }

      // Create audit info
      const auditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: userId,
        updatedAt: new Date().toISOString(),
        updatedBy: userId,
      };

      const task = await prisma.task.create({
        data: {
          title: title.trim(),
          description: description?.trim() || null,
          assignedTo: parseInt(assignedTo),
          assignedBy: userId,
         
          priority,
          dueDate: dueDate ? new Date(dueDate) : null,
          
          auditInfo,
        },
        include: {
          assignee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          assigner: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
      });

      res.status(201).json({
        success: true,
        data: task,
        message: "Task created successfully",
      });
    } catch (error) {
      console.error('Create task error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create task',
      });
    }
  }
);

// PATCH /api/admin/tasks/:id/status - Update task status
router.patch(
  "/tasks/:id/status",
  authenticateToken,
  async (req: Request, res: Response) => {
    try {
      const taskId = parseInt(req.params.id);
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;
      const { status } = req.body;

      if (isNaN(taskId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid task ID",
        });
      }

      if (!status || !['todo', 'ongoing', 'complete', 'cancelled'].includes(status)) {
        return res.status(400).json({
          success: false,
          error: "Valid status is required",
        });
      }

      // Check if task exists and user has permission
      const existingTask = await prisma.task.findUnique({
        where: { id: taskId },
      });

      if (!existingTask) {
        return res.status(404).json({
          success: false,
          error: "Task not found",
        });
      }

      // Check permissions - manager who created it or assigned editor can update status
      const canUpdateStatus = userRole === 'admin' ||
        existingTask.assignedBy === userId ||
        existingTask.assignedTo === userId;

      if (!canUpdateStatus) {
        return res.status(403).json({
          success: false,
          error: "Not authorized to update this task status",
        });
      }

      // Update task status
      const updateData: any = {
        status,
        auditInfo: {
          ...(typeof existingTask.auditInfo === 'object' && existingTask.auditInfo !== null
            ? existingTask.auditInfo as Record<string, any>
            : {}),
          updatedAt: new Date().toISOString(),
          updatedBy: userId,
        },
      };

      // Set completion date if marking as complete
      if (status === 'complete' && !existingTask.completedAt) {
        updateData.completedAt = new Date();
      } else if (status !== 'complete') {
        updateData.completedAt = null;
      }

      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: updateData,
        include: {
          assignee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          assigner: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
      });

      res.json({
        success: true,
        data: updatedTask,
        message: "Task status updated successfully",
      });
    } catch (error) {
      console.error('Update task status error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update task status',
      });
    }
  }
);

// DELETE /api/admin/tasks/:id - Delete task
router.delete(
  "/tasks/:id",
  authenticateToken,
  requireAdminOrManager,
  async (req: Request, res: Response) => {
    try {
      const taskId = parseInt(req.params.id);
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;

      if (isNaN(taskId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid task ID",
        });
      }

      // Check if task exists and user has permission
      const existingTask = await prisma.task.findUnique({
        where: { id: taskId },
      });

      if (!existingTask) {
        return res.status(404).json({
          success: false,
          error: "Task not found",
        });
      }

      // Check permissions
      const canDelete = userRole === 'admin' || existingTask.assignedBy === userId;

      if (!canDelete) {
        return res.status(403).json({
          success: false,
          error: "Not authorized to delete this task",
        });
      }

      // Delete task comments first (cascade should handle this, but being explicit)
      await prisma.taskComment.deleteMany({
        where: { taskId: taskId },
      });

      // Delete the task
      await prisma.task.delete({
        where: { id: taskId },
      });

      res.json({
        success: true,
        message: "Task deleted successfully",
      });
    } catch (error) {
      console.error('Delete task error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete task',
      });
    }
  }
);

// ======================== PUBLIC/LESS RESTRICTED ENDPOINTS ========================

// GET /api/admin/faculties - Get faculties by university
router.get("/faculties", async (req: Request, res: Response) => {
  try {
    const { universityId } = req.query;

    const whereClause: any = { isActive: true };
    if (universityId) {
      whereClause.universityId = parseInt(universityId as string);
    }

    const faculties = await prisma.faculty.findMany({
      where: whereClause,
      select: {
        id: true,
        name: true,
        universityId: true,
      },
      orderBy: { name: "asc" },
    });

    res.json({
      success: true,
      data: faculties,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch faculties",
      details: error.message,
    });
  }
});

// GET /api/admin/departments - Get departments by faculty
router.get("/departments", async (req: Request, res: Response) => {
  try {
    const { facultyId } = req.query;

    const whereClause: any = { isActive: true };
    if (facultyId) {
      whereClause.facultyId = parseInt(facultyId as string);
    }

    const departments = await prisma.department.findMany({
      where: whereClause,
      select: {
        id: true,
        name: true,
        facultyId: true,
      },
      orderBy: { name: "asc" },
    });

    res.json({
      success: true,
      data: departments,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch departments",
      details: error.message,
    });
  }
});

// GET /api/admin/subjects - Get subjects by level
router.get("/subjects", async (req: Request, res: Response) => {
  try {
    const { level } = req.query;

    const whereClause: any = { isActive: true };
    if (level) {
      whereClause.level = (level as string).toUpperCase();
    }

    const subjects = await prisma.subject.findMany({
      where: whereClause,
      select: {
        id: true,
        code: true,
        name: true,
        level: true,
      },
      orderBy: [{ level: "asc" }, { code: "asc" }],
    });

    res.json({
      success: true,
      data: subjects,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch subjects",
      details: error.message,
    });
  }
});

// GET /api/admin/streams - Get all streams
router.get("/streams", async (req: Request, res: Response) => {
  try {
    const streams = await prisma.stream.findMany({
      where: { isActive: true },
      select: {
        id: true,
        name: true,
      },
      orderBy: { name: "asc" },
    });

    res.json({
      success: true,
      data: streams,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch streams",
      details: error.message,
    });
  }
});

// GET /api/admin/frameworks - Get frameworks by type
router.get("/frameworks", async (req: Request, res: Response) => {
  try {
    const { type } = req.query;

    const whereClause: any = {};
    if (type) {
      whereClause.type = type as string;
    }

    const frameworks = await prisma.framework.findMany({
      where: whereClause,
      select: {
        id: true,
        type: true,
        qualificationCategory: true,
        level: true,
        year: true,
      },
      orderBy: [{ type: "asc" }, { level: "asc" }],
    });

    res.json({
      success: true,
      data: frameworks,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch frameworks",
      details: error.message,
    });
  }
});

// Get unique framework types
router.get("/framework-types", async (req: Request, res: Response) => {
  try {
    const uniqueTypes = await prisma.framework.findMany({
      select: { type: true },
      distinct: ["type"],
      orderBy: { type: "asc" },
    });

    res.json({
      success: true,
      data: uniqueTypes.map((f: { type: string }) => f.type),
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch framework types",
      details: error.message,
    });
  }
});

// Get levels by framework type
router.get("/framework-levels/:type", async (req: Request, res: Response) => {
  try {
    const { type } = req.params;

    const frameworks = await prisma.framework.findMany({
      where: { type: type as "SLQF" | "NVQ" },
      select: { id: true, level: true },
      orderBy: { level: "asc" },
    });

    res.json({
      success: true,
      data: frameworks,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch framework levels",
      details: error.message,
    });
  }
});

// GET /api/admin/major-fields - Fetch all major fields
router.get("/major-fields", async (req: Request, res: Response) => {
  try {
    console.log("📚 Fetching major fields...");

    const majorFields = await prisma.majorField.findMany({
      where: {
        isActive: true,
      },
      select: {
        id: true,
        name: true,
        description: true,
        isActive: true,
        auditInfo: true,
      },
      orderBy: {
        name: "asc",
      },
    });

    console.log(`✅ Found ${majorFields.length} major fields`);

    res.json({
      success: true,
      data: majorFields,
      count: majorFields.length,
    });
  } catch (error: any) {
    console.error("❌ Error fetching major fields:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch major fields",
      details: error.message,
    });
  }
});

// GET /api/admin/sub-fields - Fetch all sub fields
router.get("/sub-fields", async (req: Request, res: Response) => {
  try {
    console.log("📋 Fetching sub fields...");

    const subFields = await prisma.subField.findMany({
      where: {
        isActive: true,
      },
      include: {
        majorField: {
          select: {
            id: true,
            name: true,
          },
        },
      },
      orderBy: [{ majorId: "asc" }, { name: "asc" }],
    });

    const transformedSubFields = subFields.map(
      (subField: {
        id: number;
        name: string;
        majorId: number;
        description: string | null;
        isActive: boolean;
        auditInfo: any;
        majorField: {
          id: number;
          name: string;
        };
      }) => ({
        id: subField.id,
        name: subField.name,
        majorId: subField.majorId,
        description: subField.description,
        majorField: subField.majorField,
        isActive: subField.isActive,
        auditInfo: subField.auditInfo,
      })
    );

    console.log(`✅ Found ${transformedSubFields.length} sub fields`);

    res.json({
      success: true,
      data: transformedSubFields,
      count: transformedSubFields.length,
    });
  } catch (error: any) {
    console.error("❌ Error fetching sub fields:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch sub fields",
      details: error.message,
    });
  }
});

// GET /api/admin/sub-fields/by-major/:majorId - Fetch sub fields for specific major
router.get(
  "/sub-fields/by-major/:majorId",
  async (req: Request, res: Response) => {
    try {
      const majorId = parseInt(req.params.majorId);

      if (isNaN(majorId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid major field ID",
        });
      }

      console.log(`📋 Fetching sub fields for major ID: ${majorId}`);

      const subFields = await prisma.subField.findMany({
        where: {
          majorId: majorId,
          isActive: true,
        },
        include: {
          majorField: {
            select: {
              id: true,
              name: true,
            },
          },
        },
        orderBy: {
          name: "asc",
        },
      });

      console.log(
        `✅ Found ${subFields.length} sub fields for major ID ${majorId}`
      );

      res.json({
        success: true,
        data: subFields,
        count: subFields.length,
      });
    } catch (error: any) {
      console.error("❌ Error fetching sub fields by major:", error);
      res.status(500).json({
        success: false,
        error: "Failed to fetch sub fields for major",
        details: error.message,
      });
    }
  }
);

// POST /api/admin/major-fields - Create new major field
router.post("/major-fields", authenticateToken, requireAdminOrManagerOrEditor, async (req: Request, res: Response) => {
  try {
    const { name, description } = req.body;

    // Validation
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: "Major field name is required and must be a non-empty string",
      });
    }

    const trimmedName = name.trim();

    // Check if major field with same name already exists
    const existingMajorField = await prisma.majorField.findFirst({
      where: {
        name: {
          equals: trimmedName,
          mode: 'insensitive'
        },
        isActive: true
      }
    });

    if (existingMajorField) {
      return res.status(400).json({
        success: false,
        error: "A major field with this name already exists",
      });
    }

    console.log(`📚 Creating new major field: ${trimmedName}`);

    const auditInfo = {
      createdAt: new Date().toISOString(),
      createdBy: req.user?.id || 'system',
      updatedAt: new Date().toISOString(),
      updatedBy: req.user?.id || 'system',
    };

    const newMajorField = await prisma.majorField.create({
      data: {
        name: trimmedName,
        description: description && typeof description === 'string' ? description.trim() || null : null,
        auditInfo: auditInfo,
      },
    });

    console.log(`✅ Major field created with ID: ${newMajorField.id}`);

    res.status(201).json({
      success: true,
      data: newMajorField,
      message: "Major field created successfully",
    });
  } catch (error: any) {
    console.error("❌ Error creating major field:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create major field",
      details: error.message,
    });
  }
});

// POST /api/admin/sub-fields - Create new sub field
router.post("/sub-fields", authenticateToken, requireAdminOrManagerOrEditor, async (req: Request, res: Response) => {
  try {
    const { name, description, majorId } = req.body;

    // Validation
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: "Sub field name is required and must be a non-empty string",
      });
    }

    if (!majorId || typeof majorId !== 'number') {
      return res.status(400).json({
        success: false,
        error: "Valid major field ID is required",
      });
    }

    const trimmedName = name.trim();

    // Check if major field exists
    const majorField = await prisma.majorField.findFirst({
      where: {
        id: majorId,
        isActive: true
      }
    });

    if (!majorField) {
      return res.status(400).json({
        success: false,
        error: "Major field not found or is not active",
      });
    }

    // Check if sub field with same name already exists for this major field
    const existingSubField = await prisma.subField.findFirst({
      where: {
        name: {
          equals: trimmedName,
          mode: 'insensitive'
        },
        majorId: majorId,
        isActive: true
      }
    });

    if (existingSubField) {
      return res.status(400).json({
        success: false,
        error: "A sub field with this name already exists for this major field",
      });
    }

    console.log(`📋 Creating new sub field: ${trimmedName} for major field ID: ${majorId}`);

    const auditInfo = {
      createdAt: new Date().toISOString(),
      createdBy: req.user?.id || 'system',
      updatedAt: new Date().toISOString(),
      updatedBy: req.user?.id || 'system',
    };

    const newSubField = await prisma.subField.create({
      data: {
        name: trimmedName,
        description: description && typeof description === 'string' ? description.trim() || null : null,
        majorId: majorId,
        auditInfo: auditInfo,
      },
      include: {
        majorField: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    console.log(`✅ Sub field created with ID: ${newSubField.id}`);

    res.status(201).json({
      success: true,
      data: newSubField,
      message: "Sub field created successfully",
    });
  } catch (error: any) {
    console.error("❌ Error creating sub field:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create sub field",
      details: error.message,
    });
  }
});

// ======================== PROTECTED CREATION/MODIFICATION ENDPOINTS ========================

// GET /api/admin/career-pathways/search - Search career pathways
router.get("/career-pathways/search", async (req: Request, res: Response) => {
  try {
    const { jobTitle, industry } = req.query;

    let whereClause: any = { isActive: true };

    if (jobTitle) {
      whereClause.jobTitle = {
        contains: jobTitle as string,
        mode: "insensitive",
      };
    }

    if (industry) {
      whereClause.industry = {
        contains: industry as string,
        mode: "insensitive",
      };
    }

    const careerPathways = await prisma.careerPathway.findMany({
      where: whereClause,
      select: {
        id: true,
        jobTitle: true,
        industry: true,
        description: true,
        salaryRange: true,
      },
      take: 10,
      orderBy: { jobTitle: "asc" },
    });

    res.json({
      success: true,
      data: careerPathways,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to search career pathways",
      details: error.message,
    });
  }
});

// GET /api/admin/career-pathways - Get all career pathways
router.get("/career-pathways", async (req: Request, res: Response) => {
  try {
    const careerPathways = await prisma.careerPathway.findMany({
      where: { isActive: true },
      orderBy: { jobTitle: "asc" },
    });

    res.json({
      success: true,
      data: careerPathways,
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: "Failed to fetch career pathways",
      details: error.message,
    });
  }
});

// POST /api/admin/career-pathways - Create career pathway
router.post(
  "/career-pathways",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const { jobTitle, industry, description, salaryRange } = req.body;

      if (!jobTitle) {
        return res.status(400).json({
          success: false,
          error: "Job title is required",
        });
      }

      const auditInfo: AuditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: (req as any).user?.email || "admin",
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      const careerPathway = await prisma.careerPathway.create({
        data: {
          jobTitle,
          industry: industry || null,
          description: description || null,
          salaryRange: salaryRange || null,
          auditInfo,
        },
      });

      res.status(201).json({
        success: true,
        data: careerPathway,
        message: "Career pathway created successfully",
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: "Failed to create career pathway",
        details: error.message,
      });
    }
  }
);

// POST /api/admin/major-fields - Create new major field
router.post(
  "/major-fields",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const { name, description } = req.body;

      if (!name || !name.trim()) {
        return res.status(400).json({
          success: false,
          error: "Major field name is required",
        });
      }

      console.log("📚 Creating new major field:", name);

      const auditInfo: AuditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: (req as any).user?.email || "admin",
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      const majorField = await prisma.majorField.create({
        data: {
          name: name.trim(),
          description: description?.trim() || null,
          isActive: true,
          auditInfo,
        },
      });

      console.log("✅ Major field created successfully:", majorField.id);

      res.status(201).json({
        success: true,
        data: majorField,
        message: "Major field created successfully",
      });
    } catch (error: any) {
      console.error("❌ Error creating major field:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create major field",
        details: error.message,
      });
    }
  }
);

// POST /api/admin/sub-fields - Create new sub field
router.post(
  "/sub-fields",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const { name, majorId, description } = req.body;

      if (!name || !name.trim()) {
        return res.status(400).json({
          success: false,
          error: "Sub field name is required",
        });
      }

      if (!majorId || isNaN(parseInt(majorId))) {
        return res.status(400).json({
          success: false,
          error: "Valid major field ID is required",
        });
      }

      console.log("📋 Creating new sub field:", name, "for major ID:", majorId);

      const majorField = await prisma.majorField.findUnique({
        where: { id: parseInt(majorId) },
      });

      if (!majorField) {
        return res.status(404).json({
          success: false,
          error: "Major field not found",
        });
      }

      const auditInfo: AuditInfo = {
        createdAt: new Date().toISOString(),
        createdBy: (req as any).user?.email || "admin",
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      const subField = await prisma.subField.create({
        data: {
          name: name.trim(),
          majorId: parseInt(majorId),
          description: description?.trim() || null,
          isActive: true,
          auditInfo,
        },
        include: {
          majorField: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      console.log("✅ Sub field created successfully:", subField.id);

      res.status(201).json({
        success: true,
        data: subField,
        message: "Sub field created successfully",
      });
    } catch (error: any) {
      console.error("❌ Error creating sub field:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create sub field",
        details: error.message,
      });
    }
  }
);

// PUT /api/admin/major-fields/:id - Update major field
router.put(
  "/major-fields/:id",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      const { name, description, isActive } = req.body;

      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Invalid major field ID",
        });
      }

      console.log("📚 Updating major field ID:", id);

      const existingMajorField = await prisma.majorField.findUnique({
        where: { id },
      });

      if (!existingMajorField) {
        return res.status(404).json({
          success: false,
          error: "Major field not found",
        });
      }

      const updateData: any = {};
      if (name !== undefined) updateData.name = name.trim();
      if (description !== undefined)
        updateData.description = description?.trim() || null;
      if (isActive !== undefined) updateData.isActive = Boolean(isActive);

      // Update audit info
      const currentAuditInfo = existingMajorField.auditInfo as AuditInfo;
      updateData.auditInfo = {
        ...currentAuditInfo,
        updatedAt: new Date().toISOString(),
        updatedBy: (req as any).user?.email || "admin",
      };

      const updatedMajorField = await prisma.majorField.update({
        where: { id },
        data: updateData,
      });

      console.log("✅ Major field updated successfully:", id);

      res.json({
        success: true,
        data: updatedMajorField,
        message: "Major field updated successfully",
      });
    } catch (error: any) {
      console.error("❌ Error updating major field:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update major field",
        details: error.message,
      });
    }
  }
);

// DELETE /api/admin/major-fields/:id - Delete (soft delete) major field
router.delete(
  "/major-fields/:id",
  authenticateToken,
  requireAdmin,
  async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);

      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          error: "Invalid major field ID",
        });
      }

      console.log("🗑️ Soft deleting major field ID:", id);

      const existingMajorField = await prisma.majorField.findUnique({
        where: { id },
      });

      if (!existingMajorField) {
        return res.status(404).json({
          success: false,
          error: "Major field not found",
        });
      }

      // Check if there are active sub fields using this major field
      const activeSubFields = await prisma.subField.count({
        where: {
          majorId: id,
          isActive: true,
        },
      });

      if (activeSubFields > 0) {
        return res.status(400).json({
          success: false,
          error: `Cannot delete major field. There are ${activeSubFields} active sub fields using this major field.`,
          details: "Please deactivate or delete the sub fields first.",
        });
      }

      // Soft delete by setting isActive to false
      const currentAuditInfo = existingMajorField.auditInfo as AuditInfo;
      const updatedMajorField = await prisma.majorField.update({
        where: { id },
        data: {
          isActive: false,
          auditInfo: {
            ...currentAuditInfo,
            updatedAt: new Date().toISOString(),
            updatedBy: (req as any).user?.email || "admin",
            deletedAt: new Date().toISOString(),
            deletedBy: (req as any).user?.email || "admin",
          },
        },
      });

      console.log("✅ Major field soft deleted successfully:", id);

      res.json({
        success: true,
        data: updatedMajorField,
        message: "Major field deleted successfully",
      });
    } catch (error: any) {
      console.error("❌ Error deleting major field:", error);
      res.status(500).json({
        success: false,
        error: "Failed to delete major field",
        details: error.message,
      });
    }
  }
);
// Add this POST endpoint to your adminRoutes.ts file after the existing framework GET endpoints

// POST /api/admin/frameworks - Create new framework
router.post("/frameworks", async (req: Request, res: Response) => {
  try {
    const { type, qualificationCategory, level, year } = req.body;

    // Validation
    if (!type || !qualificationCategory || level === undefined || level === null) {
      return res.status(400).json({
        success: false,
        error: "Type, qualification category, and level are required",
      });
    }

    // Validate framework type
    if (!['SLQF', 'NVQ'].includes(type)) {
      return res.status(400).json({
        success: false,
        error: "Framework type must be either 'SLQF' or 'NVQ'",
      });
    }

    // REMOVED: Level range validation since you want free-form input
    
    // Check if framework with same type, level, and qualification category already exists
    const existingFramework = await prisma.framework.findFirst({
      where: {
        type: type as "SLQF" | "NVQ",
        level: parseInt(level),
        qualificationCategory: qualificationCategory,
      },
    });

    if (existingFramework) {
      return res.status(409).json({
        success: false,
        error: `Framework already exists for ${type} Level ${level} with qualification category "${qualificationCategory}"`,
      });
    }

    // Create the framework
    const framework = await prisma.framework.create({
      data: {
        type: type as "SLQF" | "NVQ",
        qualificationCategory: qualificationCategory.trim(),
        level: parseInt(level),
        year: year ? parseInt(year) : undefined,
      },
    });

    console.log("Framework created successfully:", framework);

    res.status(201).json({
      success: true,
      data: framework,
      message: "Framework created successfully",
    });
  } catch (error: any) {
    console.error("Error creating framework:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create framework",
      details: error.message,
    });
  }
});

// PUT /api/admin/frameworks/:id - Update framework
router.put("/frameworks/:id", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { type, qualificationCategory, level, year } = req.body;

    // Check if framework exists
    const existingFramework = await prisma.framework.findUnique({
      where: { id: parseInt(id) },
    });

    if (!existingFramework) {
      return res.status(404).json({
        success: false,
        error: "Framework not found",
      });
    }

    // Validation
    if (type && !['SLQF', 'NVQ'].includes(type)) {
      return res.status(400).json({
        success: false,
        error: "Framework type must be either 'SLQF' or 'NVQ'",
      });
    }

    // REMOVED: Level range validation

    // Update the framework
    const updatedFramework = await prisma.framework.update({
      where: { id: parseInt(id) },
      data: {
        ...(type && { type: type as "SLQF" | "NVQ" }),
        ...(qualificationCategory && { qualificationCategory: qualificationCategory.trim() }),
        ...(level && { level: parseInt(level) }),
        ...(year !== undefined && { year: year ? parseInt(year) : null }),
      },
    });

    res.json({
      success: true,
      data: updatedFramework,
      message: "Framework updated successfully",
    });
  } catch (error: any) {
    console.error("Error updating framework:", error);
    res.status(500).json({
      success: false,
      error: "Failed to update framework",
      details: error.message,
    });
  }
});

// DELETE /api/admin/frameworks/:id - Delete framework
router.delete("/frameworks/:id", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    // Check if framework exists
    const existingFramework = await prisma.framework.findUnique({
      where: { id: parseInt(id) },
    });

    if (!existingFramework) {
      return res.status(404).json({
        success: false,
        error: "Framework not found",
      });
    }

    // Check if framework is being used by any courses
    const coursesUsingFramework = await prisma.course.count({
      where: { frameworkId: parseInt(id) },
    });

    if (coursesUsingFramework > 0) {
      return res.status(409).json({
        success: false,
        error: `Cannot delete framework. ${coursesUsingFramework} course(s) are using this framework.`,
        details: "Please update or delete the courses first before deleting this framework.",
      });
    }

    // Delete the framework
    await prisma.framework.delete({
      where: { id: parseInt(id) },
    });

    res.json({
      success: true,
      message: "Framework deleted successfully",
    });
  } catch (error: any) {
    console.error("Error deleting framework:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete framework",
      details: error.message,
    });
  }
});

// ======================== COURSE MANAGEMENT ENDPOINTS ========================

// POST /api/admin/courses - Create new course
router.post('/courses', async (req: Request, res: Response) => {
  await addCourse(req, res);
});

// POST /api/admin/courses/:courseId/materials - Upload course material
router.post('/courses/:courseId/materials', async (req: Request, res: Response) => {
  await uploadCourseMaterial(req, res);
});

// GET /api/admin/courses/form-data - Get all data needed for course form (DISABLED - Using courseManagementRoutes.ts)
/*
router.get('/courses/form-data', async (req: Request, res: Response) => {
  try {
    // Fetch all required data for the form
    const [universities, faculties, departments, majorFields, subFields, frameworks, streams, subjects, careerPathways] = await Promise.all([
      prisma.university.findMany({
        where: { isActive: true },
        select: { id: true, name: true, type: true },
        orderBy: { name: 'asc' }
      }),
      prisma.faculty.findMany({
        where: { isActive: true },
        select: { id: true, name: true, universityId: true },
        orderBy: { name: 'asc' }
      }),
      prisma.department.findMany({
        where: { isActive: true },
        select: { id: true, name: true, facultyId: true },
        orderBy: { name: 'asc' }
      }),
      prisma.majorField.findMany({
        where: { isActive: true },
        select: { id: true, name: true, description: true },
        orderBy: { name: 'asc' }
      }),
      prisma.subField.findMany({
        where: { isActive: true },
        select: { id: true, name: true, majorId: true },
        orderBy: { name: 'asc' }
      }),
      prisma.framework.findMany({
        select: { id: true, type: true, qualificationCategory: true, level: true, year: true },
        orderBy: [{ type: 'asc' }, { level: 'asc' }]
      }),
      prisma.stream.findMany({
        where: { isActive: true },
        select: { id: true, name: true, streamRule: true },
        orderBy: { name: 'asc' }
      }),
      prisma.subject.findMany({
        where: { isActive: true },
        select: { id: true, code: true, name: true, level: true },
        orderBy: [{ level: 'asc' }, { name: 'asc' }]
      }),
      prisma.careerPathway.findMany({
        where: { isActive: true },
        select: { id: true, jobTitle: true, industry: true, description: true, salaryRange: true },
        orderBy: { jobTitle: 'asc' }
      })
    ]);

    res.json({
      success: true,
      data: {
        universities,
        faculties,
        departments,
        majorFields,
        subFields,
        frameworks,
        streams,
        subjects: {
          al: subjects.filter(s => s.level === 'AL'),
          ol: subjects.filter(s => s.level === 'OL')
        },
        careerPathways
      }
    });

  } catch (error: any) {
    console.error('Error fetching form data:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch form data',
      details: error.message
    });
  }
});
*/

export default router;
